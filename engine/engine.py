import pygame, pygame.locals, time
from .inputsystem import InputSystem
from .scene import Scene
from .collisionsystem import CollisionSystem
from .soundsystem import SoundSystem

class Singleton(type):
    _instances = {}
    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)
        return cls._instances[cls]

class Engine(metaclass=Singleton):

    def __init__(self):
        pygame.init()
        self.inputSystem = InputSystem()
        self.collisionSystem = CollisionSystem()
        self.soundSystem = SoundSystem()
        self.scene = None
        self.window = None # this is the "logic window"
        self.viewport = None # this is the actual window, after scaling
        self.quit = False
        self.newTime = time.time()
        self.oldTime = self.newTime
        self.sceneFileName = ""

    def loadScene(self, fileName):
        self.sceneFileName = fileName

    def __loadScene(self, fileName):
        if self.scene is not None:
            self.scene.unload()
            self.inputSystem.reset()
            self.collisionSystem.reset()

        # Level setup code
        self.scene = Scene.staticCreateFromFile(fileName)

        if self.scene is None:
            return

        # setup the window
        r = self.scene.windowRect
        scale = self.scene.scale
        self.viewport = pygame.display.set_mode((r.width * scale, r.height * scale), 0, 32)
        self.window = pygame.Surface((r.width, r.height), 0, 32)
        pygame.display.set_caption(self.scene.title)

        self.scene.load()

    def gameLoop(self):
        while not self.quit:

            # deferred scene loading
            if self.sceneFileName != "":
                self.__loadScene(self.sceneFileName)
                self.sceneFileName = ""

            self.processEvents()
            self.update()
            self.render()
        
        pygame.quit()

    def processEvents(self):
        # process all the events generated by the system, this also pumps the event queue
        for event in pygame.event.get():
            # event QUIT is generated when the user closes the application window
            if event.type == pygame.locals.QUIT:
                self.quit = True
        
        self.inputSystem.process()
        self.collisionSystem.process()

    def update(self):
        self.newTime = time.time()
        deltaTime = min(self.newTime - self.oldTime, 1.0 / 30.0)
        self.scene.update(deltaTime)

        self.oldTime = self.newTime # prepare for the next frame

    
    def getGameMode(self):
        return self.scene.gamemode

    def render(self):
        # render the scene
        self.scene.render(self.window)

        # scale to the viewport resolution
        r = self.window.get_rect()
        s = self.scene.scale
        buffer = pygame.transform.scale(self.window, (r.width * s, r.height * s))
        self.viewport.blit(buffer, self.viewport.get_rect())
        pygame.display.flip()


        # update the display with the new content of the window
        pygame.display.update()